***
# Стажировка в моторике 2023

## **Sprint-3**. Финальная попытка.

Стажировка проводится компанией моторика в кооперации с [SkillFactory.](https://skillfactory.ru/)

## **Задача**: Получить рабочую модель для отработки на протезе

## Варианты решений:

* ### [**baseline**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/Read%20data%20and%20Inference.ipynb "От организаторов"): Базовый скрипт от организаторов.

* ### [**Super_light_version**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/_super%20short%20solution%20Mike_A_palm_readable.ipynb "Для практической пробы"): Облегчённая версия (без визуализации). Всего 9 блоков кода.

* ### [**Light_version**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/light_ver_sprint_3_Aubakirov.ipynb "Подготовка к Q&A сессии"): Полное решение. Визуализации, обоснования принятия решений.

## 0. Содержание:

1. [Обзор данных](#1-обзор-данных)
2. [Блок предпроцессинга](#2-блок-предпроцессинга)
3. [Блок модели](#3-блок-модели)
4. [Блок постпроцессинга](#4-блок-постпроцессинга)
5. [Визуализация результатов](#5-визуализация-результатов)
6. [Итоги](#6-итоги)

***
## **1. Обзор данных**:

В спринте 3 данные представлены в `.palm` разрешении.

Стоит отдельно сказать, что данные между спринтами в рамках одного пилота объединять нельзя.
Только данные за 3 спринт можно объединять между монтажами.
Особенности данных 3 спринта:
- наличие наводки на сигнал, тк при записи данных ноутбук, на который писались данные, был включен в сеть;
- датчик на 8 каналов из-за чего 12 каналов первого порядка, вместо 16 (в спринтах 1 и 2).

| **Pilot_1_mount1** | **Pilot_1_mount2** |
| - | - |
| [**sprint3_pilote1_mount1_gestures.palm**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/sprint3_pilote1_mount1_gestures.palm.protocol.csv "Первый монтаж") | [**sprint3_pilote1_mount2_gestures.palm**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/sprint3_pilote1_mount2_gestures.palm.protocol.csv "Второй монтаж") |


*Fig_1. Разница в виде данных для разных монтажей, для одного пилота*

!['Разные монтажи'](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/Figure%200.png)

## 2. Блок предпроцессинга

[наверх](#0-содержание)

В качестве предпроцессинга реализовано потрясающее **"ничего"**

Так и не получилось прикрутить сюда классификатор определяющий наличие или отсутствие движения.

## 3. Блок модели

[наверх](#0-содержание)

Самая лучшая модель - `LinearRegression()`.

```python
from sklearn.linear_model import LinearRegression

model = LinearRegression().fit(X_gestures, y_gestures)
```

## 4. Блок постпроцессинга

[наверх](#0-содержание)

В качестве постпроцессинга используется дискретизация полученных предсказаний на `100/step` - уровней (по умолчанию 20 уровней по 5 единиц в каждом)

```python
def postprocessing(array, step=5):
    """_дискретизация выходных сигналов по 100/step количеству уровней
        по умолчанию step=5 -> 20 уровней сигналов_
    """
    array[array < 0] = 0
    array = np.round(array / step, 0).astype(int) * step
    return array
```

Плюс сглаживатель пиков организованный на экспоненциальном фильтре Холта-Винтерса и последующим выполнением дискретизации.

Идея такова:

1. После применения дискретизации - получаем пилообразный сигнал.
2. Пилообразный сигнал сглаживаем эксп.фильтром (пики становятся чуть ниже)
3. При повторной дискретизации пик становится чуть ниже границы и соответственно опускается на 1 уровень ниже.
4. Шаги 2 и 3 можно повторять вплоть до получения ровной линии.

```python
def commands(array, y_prev, times=2, step=10):
    """_Функция формирующая управляющие комманды
        по умолчанию происходит двухкратное последовательное срезание пиков 
        фильтром Холтом-Винтерсом с последующей дискретизация_        
    """
    if y_prev is None:
        return array
    else:
        if times == 1: #однократный срез пиков
            result = array*0.5 + y_prev*0.5
            result = np.round(array / step, 0).astype(int) * step
            result[result > 100] = 100
            return result
        elif times == 2: #двухкратный срез
            result = array*0.5 + y_prev*0.5
            result = postprocessing(result)
            result = result*0.6 + y_prev*0.4
            result = postprocessing(result)
            return result
```

## 5. Визуализация результатов

[наверх](#0-содержание)

### Финальный сет:

* Данные для моделирования - последовательно соединённые данные 2-х монтажей, 1-го пилота.
* Подготовлена к работе **1 модель** (`LinearRegression()`)
* Предпроцессинг - `Ничего`
* Постпроцессинг:
* * **дискретизация таргетов** на заданное количество диапазонов (по умолчанию 20 диапазон, по 5 единиц в каждом) 
* * **сглаживатель пиков** последовательное применение дискретизации и экпоненциального фильтра, по текущему и предыдущему предсказанию.

*Fig_2. Отработка модели принятия решения (для каждого пальца)

!['Разные монтажи'](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/Figure%202.png)

*Fig_23. Укрупнённый фрагмент отработки модели принятия решений для ENC3

!['Разные монтажи'](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/Figure%201.png)

## 6. Итоги третьего спринта и **практики в целом**.

[наверх](#0-содержание)

### **Задача:** Получить модель принятия решений для плавной регулировки сжатия пальцев протеза по данным от OMG датчика 

### **Проблемы:**
1. Неустойчивость **сигналов** датчика (характер и величина сигнала меняются от всего на свете, от монтажа, пилота, времени, внешних элмагнитных полей и пр.)

2. Неустойчивость **"положения"** активных датчиков (в зависимости от положения датчика активными будут разные каналы. К примеру там где модель научилась видеть "сгибание мизинца" на следующем монтаже может быть "разгибание безымянного")

3. Ограничения **по железу** (первое ограничение связано с недостатком вычислительных мощностей - мы не можем поставить в протез `NVIDIA DGX GH200`, второе ограничение связано с быстродействием модели - мы должны выдавать управляющий сигнал на протез **"тутже"** задержка на вычисление должна быть минимальной)

4. **Бонусная-анатомическая** - возможно на базе существующего датчика проблема является нерешаемой. Возможно не удастся получить пригодные для моделирования данные посредством оптического измерения движения кожи (и кровонаполненности мышц) на ограниченном участке предплечья.

### **Возможные пути решения:**
* **Проблема вычислительных мощностей** - может помочь использование простых инструментов, лишённых ненужных в контексте решаемой задачи атрибутов. Не стоит брать нейронку из коробки, закидывать в неё необработанные данные и "надеятся на лучшее". Лучше взять нейронку (если очень-очень хочется) выпотрошить её и оставить только те кусочки которые реально нужны в контексте решаемой задачи.

* **Проблема быстродействия** - может помочь пошаговый анализ каждой операции выполняемой моделью принятия решения (к примеру если скалирование не даёт измеримого вклада в финальный результат - выкидываем скалирование, это актуально **для каждой** операции, накапливание сигналов для фильтрации, преобразования пространства показаний датчиков и т.д.)

* **Проблема нейстойцивости "положения" активных датчиков** - может помочь отказ статичного положения датчиков, т.е. мы не ждём каких-то показаний от отдельно взятого канала (1 - "сгиб мизинца", 2- "сгиб безымянного" и т.д.). 
* * Вместо этого можно ввести `интегральные признаки` по всему пространству показаний датчиков (общий минимум, максиму, средние, стандартные отклонения, длинну вектора, направление (относительно условного нуля) и т.д.).
* * Или после преобразования пространства показаний датчиков, перейти к `динамическому поиску повторяющихся паттернов` (что-то из области кластеризации)

* **Проблема неустойчивости сигналов датчика** - магия линейной алгебры. Для приведения пространства показаний датчиков (50-и мерный вектор) к плюс минус стандартному виду может помочь последовательное преобразование данного вектора: стандартизация (50,0) - составление ковариационной матрицы (50, 50) - нахождение собственных / айгент / значений (50,0).
Есть подозрение, что PCA делает что-то похожее.

* **Бонусную-анатомическую** проблему решить прям совсем просто, надо всего лишь разработать прямой интерфей мозг-компьютер, который будет работать :)

## summary:

* Печально, что характер и положение сигналов меняються `от всего на свете`

    * Можно попытаться стандартизировать сигналы `как единое векторное пространство`

* Нужно, чтобы протез `реагировал моментально` (в идеале до 10мс)

    * Можно выкинуть **все** лишнии операции и выполнять только критически `необходимые вычисления`

* Тривиальным решением будет: **`Обучать не протез, а человека`**

    * Зашить в протез жесткую логику при `A` делай `B` и учить пилота ловить эти `A` ,`B`, `C`