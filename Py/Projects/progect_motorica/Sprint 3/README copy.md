***
# Стажировка в моторике 2023

## **Sprint-3**. Финальная попытка.

Стажировка проводится компанией моторика в кооперации с [SkillFactory.](https://skillfactory.ru/)

## **Задача**: Получить рабочую модель для прогона на протезе

## Варианты решений:

* ### [**baseline**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/Read%20data%20and%20Inference.ipynb "От организаторов"): Базовый скрипт от организаторов.

* ### [**Super_light_version**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/_super%20short%20solution%20Mike_A_palm_readable.ipynb "Для практической пробы"): Облегчённая версия (без визуализации). Всего 9 блоков кода.

* ### [**Light_version**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/light_ver_sprint_3_Aubakirov.ipynb "Подготовка к Q&A сессии"): Полное решение. Визуализации, обоснования принятия решений.

## 0. Содержание:

1. [Обзор данных](#1-обзор-данных)
2. [Блок предпроцессинга](#2-блок-предпроцессинга)
3. [Блок модели](#3-блок-модели)
4. [Блок постпроцессинга](#4-блок-постпроцессинга)
5. [Визуализация результатов](#5-визуализация-результатов)
6. [Финальный сет. Гипотезы. Вопросы](#6-финальный-сет-гипотезы-вопросы)

***
## **1. Обзор данных**:

В спринте 3 данные представлены в `.palm` разрешении.

Стоит отдельно сказать, что данные между спринтами в рамках одного пилота объединять нельзя.
Только данные за 3 спринт можно объединять между монтажами.
Особенности данных 3 спринта:
- наличие наводки на сигнал, тк при записи данных ноутбук, на который писались данные, был включен в сеть;
- датчик на 8 каналов из-за чего 12 каналов первого порядка, вместо 16 (в спринтах 1 и 2).

| **Pilot_1_mount1** | **Pilot_1_mount2** |
| - | - |
| [**sprint3_pilote1_mount1_gestures.palm**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/sprint3_pilote1_mount1_gestures.palm.protocol.csv "Первый монтаж") | [**sprint3_pilote1_mount2_gestures.palm**](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/sprint3_pilote1_mount2_gestures.palm.protocol.csv "Второй монтаж") |


*Fig_1. Разница в виде данных для разных монтажей, для одного пилота*

!['Разные монтажи'](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/Figure%200.png)

## 2. Блок предпроцессинга

[наверх](#0-содержание)

В качестве предпроцессинга реализовано потрясающее **"ничего"**

Так и не получилось прикрутить сюда классификатор определяющий наличие или отсутствие движения.

## 3. Блок модели

[наверх](#0-содержание)

Самая лучшая модель - `LinearRegression()`.

```python
from sklearn.linear_model import LinearRegression

model = LinearRegression().fit(X_gestures, y_gestures)
```

## 4. Блок постпроцессинга

[наверх](#0-содержание)

В качестве постпроцессинга используется дискретизация полученных предсказаний на `100/step` - уровней (по умолчанию 20 уровней по 5 единиц в каждом)

```python
def postprocessing(array, step=5):
    """_дискретизация выходных сигналов по 100/step количеству уровней
        по умолчанию step=5 -> 20 уровней сигналов_
    """
    array[array < 0] = 0
    array = np.round(array / step, 0).astype(int) * step
    return array
```

Плюс сглаживатель пиков организованный на экспоненциальном фильтре Холта-Винтерса и последующим выполнением дискретизации.

Идея такова:

1. После применения дискретизации - получаем пилообразный сигнал.
2. Пилообразный сигнал сглаживаем эксп.фильтром (пики становятся чуть ниже)
3. При повторной дискретизации пик становится чуть ниже границы и соответственно опускается на 1 уровень ниже.
4. Шаги 2 и 3 можно повторять вплоть до получения ровной линии.

```python
def commands(array, y_prev, times=2, step=10):
    """_Функция формирующая управляющие комманды
        по умолчанию происходит двухкратное последовательное срезание пиков 
        фильтром Холтом-Винтерсом с последующей дискретизация_        
    """
    if y_prev is None:
        return array
    else:
        if times == 1: #однократный срез пиков
            result = array*0.5 + y_prev*0.5
            result = np.round(array / step, 0).astype(int) * step
            result[result > 100] = 100
            return result
        elif times == 2: #двухкратный срез
            result = array*0.5 + y_prev*0.5
            result = postprocessing(result)
            result = result*0.6 + y_prev*0.4
            result = postprocessing(result)
            return result
```

## 5. Визуализация результатов

[наверх](#0-содержание)

### Финальный сет:

* Данные для моделирования - последовательно соединённые данные 2-х монтажей, 1-го пилота.
* Подготовлена к работе **1 модель** (`LinearRegression()`)
* Предпроцессинг - `Ничего`
* Постпроцессинг:
* * **дискретизация таргетов** на заданное количество диапазонов (по умолчанию 20 диапазон, по 5 единиц в каждом) 
* * **сглаживатель пиков** последовательное применение дискретизации и экпоненциального фильтра, по текущему и предыдущему предсказанию.

*Fig_2. Отработка модели принятия решения (для каждого пальца)

!['Разные монтажи'](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/Figure%202.png)

*Fig_23. Укрупнённый фрагмент отработки модели принятия решений для ENC3

!['Разные монтажи'](https://github.com/hoittoken/Python/blob/master/Py/Projects/progect_motorica/Sprint%203/Figure%201.png)


[наверх](#0-содержание)